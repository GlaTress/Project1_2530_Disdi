LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;

ENTITY Multiplier IS
    GENERIC(MAX_WIDTH: INTEGER := 5);
    PORT (
        A : IN  STD_LOGIC_VECTOR(MAX_WIDTH-1 DOWNTO 0);
        B : IN  STD_LOGIC_VECTOR(MAX_WIDTH-1 DOWNTO 0);
        Res : OUT STD_LOGIC_VECTOR((MAX_WIDTH*2) - 2 DOWNTO 0)
    );
END ENTITY Multiplier;

ARCHITECTURE MultiplierArch OF Multiplier IS
    SIGNAL Partial_Prod : STD_LOGIC_VECTOR((MAX_WIDTH * MAX_WIDTH) - 1             DOWNTO 0);
    SIGNAL Partial_Sum  : STD_LOGIC_VECTOR((MAX_WIDTH * (MAX_WIDTH+1)) - 1         DOWNTO 0);
BEGIN


    Partial: FOR i IN 0 TO MAX_WIDTH-1 GENERATE
        Partial2: FOR j IN 0 TO MAX_WIDTH-1 GENERATE
            Partial_Prod(i*MAX_WIDTH + j) <= A(i) AND B(j);
        END GENERATE;
    END GENERATE;

    Partial_Sum(MAX_WIDTH DOWNTO 0) <= Partial_Prod(MAX_WIDTH-1) & Partial_Prod(MAX_WIDTH-1 DOWNTO 0);

    Ripples: FOR i IN 0 TO MAX_WIDTH-2 GENERATE

        Adder: ENTITY WORK.RippleCAdder

            GENERIC MAP 
            (
                MAX_WIDTH => MAX_WIDTH
            )
            PORT MAP (
                Mode => '0',
                A => Partial_Sum((MAX_WIDTH) + (MAX_WIDTH + 1) * (i) DOWNTO ((MAX_WIDTH + 1)*(i)) + 1),
                B => Partial_Prod((MAX_WIDTH-1) + MAX_WIDTH*(i+1) DOWNTO MAX_WIDTH*(i+1)),
                S => Partial_Sum((MAX_WIDTH) + (MAX_WIDTH + 1)*(i+1) DOWNTO (MAX_WIDTH + 1)*(i+1))
            );

            Res(i) <= Partial_Sum((MAX_WIDTH + 1)*i);
    END GENERATE;

    Res(MAX_WIDTH*2 - 2 DOWNTO MAX_WIDTH-1) <= Partial_Sum(MAX_WIDTH + (MAX_WIDTH + 1)*(MAX_WIDTH-1) - 1 DOWNTO (MAX_WIDTH + 1)*(MAX_WIDTH-1));

END MultiplierArch;

